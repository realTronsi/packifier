var e={d:(t,r)=>{for(var s in r)e.o(r,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:r[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{_:()=>r});class r{constructor(e){this.id=e.id,this.req=e.req,this.pre=e.pre,this.reqlen=this.req.length,this.prelen=this.pre.length,this.segmentationThreshold=e.segmentationThreshold,this.maxUnpackIterations=Math.ceil(this.prelen/this.segmentationThreshold)}pack(e,t){const r=this.req,s=this.pre,h=this.reqlen,i=this.prelen,n=[this.id];let o=0;do{n.push(e[r[o]])}while(++o<h);if(0===i)return pack;o=0;const l=this.segmentationThreshold;let a=0,p=n.length,c=0;n[p]=a;do{c===l&&(c=0,n[p]=a,a=0,p=n.length,n[p]=a);const r=s[o];!0===t[r]&&(n.push(e[r]),a|=1<<c),++c}while(++o<i);return n[p]=a,0===n[p]&&n.pop(),n}unpack(e){const t=this.req,r=this.pre,s=this.reqlen,h=this.prelen,i=(e.length,{});let n=0;for(;n++<s;)i[t[n-1]]=e[n];if(0===h)return i;const o=this.segmentationThreshold,l=this.maxUnpackIterations;let a=0;for(n=s;n++;){let t=e[n];if(void 0===t||n>l)break;let s=0;do{0!=(t&1<<s)&&(i[r[a]]=e[++n]),++a}while(s++<o)}return i}}var s=t._;export{s as Packifier};